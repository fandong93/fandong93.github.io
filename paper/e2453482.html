<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 基础语法（中） | Mr.DONG の 自习室</title><meta name="keywords" content="Java"><meta name="author" content="Mr.DONG"><meta name="copyright" content="Mr.DONG"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="3. 类型转换 \quad 由于 Java 是一种强类型语言，所以在进行某些运算的时候，需要用到类型转换。所谓类型转换即将某一个数据的数据类型通过某种方式转换为另一种所需的数据类型。在运算中，不同类型的数据需要先转化为同一类型，然后才能进行运算。数据类型的转换可以分为 隐式转换（自动类型转换）和 显式转换（强制类型转换）两种。  3.1 隐式转换（自动类型转换） \quad 在运算中，如果满足：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础语法（中）">
<meta property="og:url" content="https://xindong2020.love/paper/e2453482.html">
<meta property="og:site_name" content="Mr.DONG の 自习室">
<meta property="og:description" content="3. 类型转换 \quad 由于 Java 是一种强类型语言，所以在进行某些运算的时候，需要用到类型转换。所谓类型转换即将某一个数据的数据类型通过某种方式转换为另一种所需的数据类型。在运算中，不同类型的数据需要先转化为同一类型，然后才能进行运算。数据类型的转换可以分为 隐式转换（自动类型转换）和 显式转换（强制类型转换）两种。  3.1 隐式转换（自动类型转换） \quad 在运算中，如果满足：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s6.jpg.cm/2022/09/07/PXRPf5.jpg">
<meta property="article:published_time" content="2022-08-29T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-13T14:38:58.995Z">
<meta property="article:author" content="Mr.DONG">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s6.jpg.cm/2022/09/07/PXRPf5.jpg"><link rel="shortcut icon" href="https://s6.jpg.cm/2022/09/07/PXPkS4.th.png"><link rel="canonical" href="https://xindong2020.love/paper/e2453482"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io/css/logofonts.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"R7ZHV2NELE","apiKey":"8aa9f67293bfb4f2895895aaaa92152f","indexName":"fandong","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 基础语法（中）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-13 22:38:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/one.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/width.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/background.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/fonts.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/logofonts.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/fontsize.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fandong93/fandong93.github.io@master/css/scrollbar.css"><link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css" rel="stylesheet"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s6.jpg.cm/2022/09/07/PXPXyi.th.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s6.jpg.cm/2022/09/07/PXRPf5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mr.DONG の 自习室</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 基础语法（中）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-29T16:00:00.000Z" title="发表于 2022-08-30 00:00:00">2022-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-13T14:38:58.995Z" title="更新于 2022-09-13 22:38:58">2022-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 基础语法（中）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="3-类型转换"><a class="markdownIt-Anchor" href="#3-类型转换"></a> 3. 类型转换</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 由于 <code>Java</code> 是一种强类型语言，所以在进行某些运算的时候，需要用到类型转换。所谓类型转换即将某一个数据的数据类型通过某种方式转换为另一种所需的数据类型。在运算中，不同类型的数据需要先转化为同一类型，然后才能进行运算。数据类型的转换可以分为 <strong>隐式转换</strong>（自动类型转换）和 <strong>显式转换</strong>（强制类型转换）两种。</p>
<h2 id="31-隐式转换自动类型转换"><a class="markdownIt-Anchor" href="#31-隐式转换自动类型转换"></a> 3.1 隐式转换（自动类型转换）</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 在运算中，如果满足：（1）两种数据类型彼此 <strong>兼容</strong>；（2）目标数据类型的取值范围大于源数据类型，那么将执行自动类型转换，转换为取值范围大的数据类型。<strong>自动类型转换主要表达数字表示范围小的数据类型可以自动转换成范围大的数据类型</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 在运算过程中，由于不同的数据类型会转换成同一种数据类型（取值范围大的数据类型），所以整型、浮点型以及字符型都可以参与混合运算。自动类型转换的规则是从低级类型数据转换成高级类型数据。转换规则如下：</p>
<ul>
<li>
<p><code>boolean</code> 类型不参与自动类型转换，值只能为 <code>true</code> 或 <code>false</code>。</p>
</li>
<li>
<p>数值型数据的转换：<code>byte</code>，<code>short</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>int</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>long</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>float</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>double</code></p>
<ul>
<li>
<p><code>byte</code>，<code>short</code>参与运算时（包含同种类型运算），会自动转换为 <code>int</code> 类型，然后参与运算，最终结果为 <code>int</code> 类型。</p>
</li>
<li>
<p>当对 <code>long</code> 类型变量进行赋值时，如果忘记在数值后加 “<code>L</code>”，会产生两种情况：</p>
<ul>
<li>数值在 <code>int</code> 取值范围内不报错，因为会将数值先定义为 <code>int</code> 类型，然后在运算过程中自动类型转换为 <code>long</code> 类型。</li>
<li>数值超出 <code>int</code> 取值范围会报错，因为无法将数值定义为 <code>int</code> 类型。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符型转换为整型：<code>char</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>int</code></p>
<ul>
<li>
<p><code>char</code> 类型比较特殊，<code>char</code> 可以自动转换成 <code>int</code>，<code>long</code>，<code>float</code> 和 <code>double</code>，但 <code>byte</code> 和 <code>short</code> 不能自动转换为 <code>char</code>，而且 <code>char</code> 也不能自动转换为 <code>byte</code> 或 <code>short</code>。</p>
</li>
<li>
<p><code>char</code> 与 <code>byte</code> 和 <code>short</code> 做运算时（包含同种类型运算），三者会自动转换为 <code>int</code> 类型，然后参与运算，最终结果为 <code>int</code> 类型。</p>
</li>
</ul>
</li>
</ul>
<h2 id="32-显式转换强制类型转换"><a class="markdownIt-Anchor" href="#32-显式转换强制类型转换"></a> 3.2 显式转换（强制类型转换）</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 当两种数据类型 <strong>不兼容</strong>，或目标数据类型的取值范围小于源数据类型时，自动转换将无法进行，这时就需要进行强制类型转换。强制数据类型转换是 <strong>手动</strong> 将较大范围数据转换较小数据类型，<strong>格式</strong>是在需要进行类型转换的数据前加上 “<code>(数据类型)</code>”，<strong>在括号内加入需要转化的数据类型</strong>。有的数据经过转型运算后，精度会丢失，而有的会更加精确。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 在强制类型转换中，如果是将浮点类型的值转换为整数，直接截断小数点后边的所有数字（损失精度）；而如果是整数类型强制转换为浮点类型时，将在小数点后面补零。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <strong>注</strong>：<strong>不能对布尔值进行强制类型转换</strong>；<strong>转换过程中可能发生内存溢出或精度问题</strong>。</p>
<h1 id="4-string"><a class="markdownIt-Anchor" href="#4-string"></a> 4. String</h1>
<ul>
<li>
<p><code>String</code> 不是基本数据类型，属于引用数据类型。</p>
</li>
<li>
<p>声明 <code>String</code> 类型变量时，必须使用一对双引号 <code>&quot;&quot;</code> 或强制类型转换。<code>8</code> 种基本数据类型不会自动转换为 <code>String</code> 类型。</p>
</li>
<li>
<p>使用方式与基本数据类型一致。例：<code>String str = &quot;Hello world!&quot;</code>。</p>
</li>
<li>
<p><code>String</code> 类型变量可以是空字符串。例：<code>String str = &quot;&quot;</code>。</p>
</li>
<li>
<p>一个字符串可以拼接另一个字符串，也可以使用 “<code>+</code>” 与 <code>8</code> 种基本数据类型（包含 <code>boolean</code> 类型）进行拼接，最终得到的结果都是字符串类型的数据。</p>
</li>
<li>
<p>“<code>+</code>” 两侧出现字符串类型数据，执行的是 <strong>拼接运算</strong> 而不是 <strong>加法运算</strong>。</p>
</li>
<li>
<p><code>String</code> 类型 <strong>不能</strong> 强制类型转换成基本数据类型，会报错。</p>
</li>
<li>
<p>练习：<code>char</code> + <code>char</code> 执行加法运算，<code>char</code> + <code>String</code> 或 <code>String</code> + <code>char</code> 执行拼接运算。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;*&#x27;</span>);<span class="comment">// 93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&#x27;*&#x27;</span>);<span class="comment">// *       *</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&quot;*&quot;</span>);<span class="comment">// 51*</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="5-java-变量"><a class="markdownIt-Anchor" href="#5-java-变量"></a> 5. Java 变量</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code> 程序在运行期间会产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都会使用一个 <strong>标识符</strong> 进行标识。这些内存单元被称为 <strong>变量</strong>，对内存单元进行标识的标识符就是 <strong>变量名</strong>，内存单元中存储的数据就是 <strong>变量的值</strong>。</p>
<ul>
<li>
<p><code>Java</code> <strong>变量作用</strong>：用于在内存中保存数据。</p>
</li>
<li>
<p><code>Java</code> 是一种强类型语言，每个变量都必须声明其数据类型，数据类型可以是基本数据类型，也可以是引用数据类型。</p>
</li>
<li>
<p><code>Java</code>变量是程序中 <strong>最基本的存储单元</strong>，其要素包括 <strong>变量名</strong>，<strong>变量类型</strong> 和 <strong>作用域</strong>。</p>
</li>
<li>
<p>在 <code>Java</code> 语言中，所有的变量在使用前必须声明。</p>
</li>
<li>
<p><strong>声明变量的基本格式</strong>：<code>type identifier [= value][, identifier [= value] ...];</code>，其中 <code>type</code> 为 <code>Java</code> 数据类型，<code>identifier</code> 是变量名。</p>
<ul>
<li>
<p>可以使用 “<code>,</code>” 分割同时声明 <strong>多个同类型</strong> 变量（<strong>不建议</strong> 同一行声明多个变量）。</p>
</li>
<li>
<p>要注意变量声明是一条完整的语句，因此每一个声明都必须以分号 “<code>;</code>” 结束。</p>
</li>
</ul>
</li>
<li>
<p><code>Java</code> 程序在声明变量的同时可以为变量赋值，也可以声明以后再赋值，需要使用变量名来访问这块区域的数据。例：</p>
<ul>
<li>
<p>声明时赋值：<code>int a = 1;</code></p>
</li>
<li>
<p>声明后赋值：<code>int a; a = 1;</code></p>
</li>
</ul>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code>变量 <strong>作用域</strong> 是指变量能生效的区域范围，变量只有在作用域范围内才能够被使用。声明在不同地方的变量具有不同的作用域，而决定作用域范围的就是花括号<code>&#123;&#125;</code>的位置。同一个作用域内，不能定义重名的变量。根据作用域的不同，一般将变量分为 <strong>成员变量</strong>（全局变量） 和 <strong>局部变量</strong>。</p>
<h2 id="51-全局变量"><a class="markdownIt-Anchor" href="#51-全局变量"></a> 5.1 全局变量</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code> 的全局变量有两种，分别是 <strong>成员变量</strong>（实例变量）和 <strong>静态变量</strong>（类变量）。成员变量声明在一个类中，但在方法、构造方法和语句块之外，不属于任何一个方法，作用域是整个类。</p>
<table>
<thead>
<tr>
<th>成员变量类型</th>
<th>修饰</th>
<th>访问</th>
<th>生命周期</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员变量（实例变量）</td>
<td>无<code>static</code>修饰</td>
<td>对象名<code>.</code>变量名</td>
<td>在对象创建的时候创建，在对象被销毁的时候销毁。</td>
</tr>
<tr>
<td>静态变量（类变量）</td>
<td><code>static</code>修饰</td>
<td>类名<code>.</code>变量名 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span> 对象名<code>.</code>变量名</td>
<td>其生命周期取决于类的生命周期。在类第一次被访问时创建，在类被垃圾回收机制彻底回收时才会被销毁。</td>
</tr>
</tbody>
</table>
<p>没有赋值的<strong>全局变量</strong>，系统将按下列默认值进行初始化：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始值</th>
<th>数据类型</th>
<th>初始值</th>
<th>数据类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>byte</strong></td>
<td>0</td>
<td><strong>short</strong></td>
<td>0</td>
<td><strong>int</strong></td>
<td>0</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>0L</td>
<td><strong>char</strong></td>
<td>‘\u0000’</td>
<td><strong>float</strong></td>
<td>0.0f</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>0.0</td>
<td><strong>boolean</strong></td>
<td>false</td>
<td><strong>所有引用类型</strong></td>
<td>null（不引用任何对象）</td>
</tr>
</tbody>
</table>
<h3 id="511-成员变量实例变量"><a class="markdownIt-Anchor" href="#511-成员变量实例变量"></a> 5.1.1 成员变量（实例变量）</h3>
<ul>
<li>
<p>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</p>
</li>
<li>
<p>当一个对象被实例化之后，每个实例变量的值就跟着确定；</p>
<ul>
<li>注：<strong>对象实例化过程</strong>：当一个对象被创建之后，虚拟机会为其分配内存，主要用来存放对象的实例变量及其从超类继承过来的实例变量，在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值。 即使我们没通过构造函数传递参数，或者 <code>set</code> 指令传递参数，那么实例变量也会被赋予默认初始值。</li>
</ul>
</li>
<li>
<p>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</p>
</li>
<li>
<p>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得在类的外部能够通过这些方式获取实例变量信息；</p>
</li>
<li>
<p>实例变量的声明可以在使用前或者使用后；</p>
<ul>
<li>因为实例变量伴随对象的创建而实例化，所以总是在第一步执行，无所谓写在前后。</li>
</ul>
</li>
<li>
<p><strong>访问修饰符</strong>（后续讲解）可以修饰实例变量；</p>
</li>
<li>
<p>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有（<strong>private</strong>，只能在本类中访问到，在其他的类中无法进行访问）。通过使用访问修饰符可以使实例变量对子类可见；</p>
</li>
<li>
<p>实例变量具有<strong>默认值</strong>。数值型变量的默认值是 <code>0</code>，布尔型变量的默认值是 <code>false</code>，引用类型变量的默认值是 <code>null</code>。变量的值可以在声明时指定，也可以在构造方法中指定；</p>
</li>
<li>
<p>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：<code>ObejectReference.VariableName</code>，即 <strong>对象名<code>.</code>变量名</strong>。</p>
</li>
</ul>
<h3 id="512-静态变量类变量"><a class="markdownIt-Anchor" href="#512-静态变量类变量"></a> 5.1.2 静态变量（类变量）</h3>
<ul>
<li>
<p>类变量也称为静态变量，在类中以 <code>static</code> 关键字声明，但必须在方法之外。</p>
</li>
<li>
<p>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝，即任意对象修改了静态变量，都会影响到所有对象。</p>
</li>
<li>
<p>静态变量会在对象实例化的时候在 <strong>堆内存</strong> 中单独创建一片固定的内存，即所有对象实例的静态变量值都指向这片区域。</p>
</li>
<li>
<p>静态变量除了被声明为常量外很少使用，<strong>静态常量</strong> 是指声明为 <code>public/private final static</code> 类型的一种常量。静态常量名称一般建议使用大写字母，静态常量初始化后不可改变。</p>
</li>
<li>
<p>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 <code>static</code> 声明变量。</p>
</li>
<li>
<p>静态变量在第一次被访问时创建，在程序结束时销毁。</p>
</li>
<li>
<p>静态变量与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 <code>public</code> 类型。</p>
</li>
<li>
<p>静态变量 <strong>默认值</strong> 和实例变量相似。数值型变量默认值是 <code>0</code>，布尔型默认值是 <code>false</code>，引用类型默认值是 <code>null</code>。变量的值可以在 <strong>声明的时候指定</strong>，也可以在 <strong>构造方法中指定</strong>。此外，静态变量还可以在 <strong>静态语句块中初始化</strong>。</p>
</li>
<li>
<p>静态变量可以通过：<code>ClassName.VariableName</code>，即 <strong>类名<code>.</code>变量名</strong> 的方式访问。</p>
</li>
<li>
<p><strong>静态变量可以在自身所在的类内部被直接访问</strong>。</p>
</li>
<li>
<p>如果静态变量不是 <code>public</code> 和 <code>final</code> 类型，其命名方式与实例变量以及局部变量的命名方式一致。</p>
</li>
</ul>
<h2 id="52-局部变量"><a class="markdownIt-Anchor" href="#52-局部变量"></a> 5.2 局部变量</h2>
<ul>
<li>
<p>局部变量声明在方法、构造方法或者语句块中；</p>
</li>
<li>
<p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p>
</li>
<li>
<p><strong>访问修饰符不能用于局部变量</strong>，即不能被 <code>public、private、protected</code> 修饰；</p>
</li>
<li>
<p>局部变量只在声明它的方法、构造方法或者语句块中可见；</p>
</li>
<li>
<p>局部变量是在栈上分配的。</p>
</li>
<li>
<p>局部变量 <strong>没有默认值</strong>，所以局部变量被声明后，<strong>必须经过初始化</strong>，才可以使用。</p>
</li>
<li>
<p>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：</p>
<ul>
<li>
<p><strong>方法参数变量</strong>（形参）：在整个方法内有效。</p>
</li>
<li>
<p><strong>方法局部变量</strong>（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。</p>
</li>
<li>
<p><strong>代码块局部变量</strong>（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。</p>
</li>
</ul>
</li>
</ul>
<h1 id="6-java-常量"><a class="markdownIt-Anchor" href="#6-java-常量"></a> 6. Java 常量</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code> 常量是指在程序的整个运行过程中值保持不变的量，即常量在程序中只能被引用，而不能被重新赋值。常量 <strong>需要初始化</strong>，即在声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。常量的语法格式和变量类型，只需要在变量的语法格式前面添加关键字 <code>final</code> 即可，其语法格式：<code>final type CONST = value [, const = value ...];</code>。<code>final</code> 关键字表示最终的，修饰变量就变成了常量。<code>final</code> 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。在 <code>Java</code> 编码规范中，要求常量名必须大写。<code>Java</code> 常量的使用一般有三种方式：</p>
<h2 id="61-interface-中定义常量"><a class="markdownIt-Anchor" href="#61-interface-中定义常量"></a> 6.1 interface 中定义常量</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java interface</code> 中声明的字段在编译时会自动加上 <code>public static final</code> 修饰符，即声明为常量。使用方法一般是 “<strong>接口<code>.</code>常量名</strong>”。</p>
<p>不推荐这种方式：</p>
<ul>
<li>
<p><code>Java</code> 中设计出接口这种语法，就是为了用来实现或者继承的，如果我们在实现类或者子类接口中定义了同名的常量，那么子类接口或者实现类引用同名的常量，就可能不一致，很容易造成混乱。</p>
</li>
<li>
<p>与接口的定义不相符，接口是一种规范，一种协议规定，主要用来定义必须要实现的 <code>API</code>。用接口来定义常量，与创造接口的目的不相符。</p>
</li>
<li>
<p>在 <code>interface</code> 中定义的常量属于编译型常量，每次更改常量值，都要重新编译所有引用到它的类。</p>
</li>
</ul>
<h2 id="62-class-中定义常量"><a class="markdownIt-Anchor" href="#62-class-中定义常量"></a> 6.2 Class 中定义常量</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantClassField</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUNDAY</span> <span class="operator">=</span> <span class="string">&quot;SUNDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MONDAY</span> <span class="operator">=</span> <span class="string">&quot;MONDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TUESDAY</span> <span class="operator">=</span> <span class="string">&quot;TUESDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEDNESDAY</span> <span class="operator">=</span> <span class="string">&quot;WEDNESDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">THURSDAY</span> <span class="operator">=</span> <span class="string">&quot;THURSDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FRIDAY</span> <span class="operator">=</span> <span class="string">&quot;FRIDAY&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SATURDAY</span> <span class="operator">=</span> <span class="string">&quot;SATURDAY&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63-enum-定义常量"><a class="markdownIt-Anchor" href="#63-enum-定义常量"></a> 6.3 enum 定义常量</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code> 枚举是一个特殊的类，一般表示一组常量。<code>class</code> 使用 <code>enum</code> 关键字来定义，各个常量之间使用逗号 <code>,</code> 来分割。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64-通过配置文件来配置常量"><a class="markdownIt-Anchor" href="#64-通过配置文件来配置常量"></a> 6.4 通过配置文件来配置常量</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 后续详解</p>
<h1 id="7-命名规范"><a class="markdownIt-Anchor" href="#7-命名规范"></a> 7. 命名规范</h1>
<ul>
<li>
<p><strong>所有变量、常量、方法和类名</strong>：见名知意</p>
</li>
<li>
<p><strong>项目名</strong>：全部小写，多个单词用中划线 “<code>-</code>” 连接。</p>
</li>
<li>
<p><strong>包名</strong>：全部小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接（例：<code>springframework</code>, <code>deepspace</code> 不需要使用任何分割）。</p>
</li>
<li>
<p><strong>类成员变量</strong>：首字母小写和驼峰原则。例：<code>monthSalary</code></p>
</li>
<li>
<p><strong>局部变量</strong>：首字母小写和驼峰原则。例：<code>weekSalary</code></p>
</li>
<li>
<p><strong>常量</strong>：大写字母和下划线。例：<code>MAX_VALUE</code></p>
</li>
<li>
<p><strong>类名</strong>：首字母大写和驼峰原则。例：<code>HelloWorld</code></p>
</li>
<li>
<p><strong>方法名</strong>：首字母小写和驼峰原则。例：<code>runProcedure()</code></p>
</li>
</ul>
<h1 id="8-运算符"><a class="markdownIt-Anchor" href="#8-运算符"></a> 8. 运算符</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>Java</code> 语言支持如下运算符：</p>
<ul>
<li>
<p>算数运算符：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>（模运算，取余），<code>++</code>，<code>--</code></p>
<ul>
<li>
<p><code>+</code>：正号、加法运算、字符串拼接。</p>
</li>
<li>
<p><code>++</code>：（前）自增、（后）自增。</p>
</li>
<li>
<p><code>--</code>：（前）自减、（后）自减。</p>
</li>
<li>
<p><code>/</code>：整型（<code>byte</code>，<code>short</code>，<code>int</code>）数值相除之后为 <code>int</code> 类型，赋给 <code>float</code> / <code>double</code> 类型变量也只是在整数末尾加 <code>.0</code>。</p>
</li>
<li>
<p><code>%</code>：运算结果的符号与被模数的符号相同。例：<code>-12 % 5</code> 的结果为 <code>-2</code>。</p>
</li>
</ul>
</li>
<li>
<p>赋值运算符：<code>=</code>，当 <code>=</code> 两侧数据类型不一致时，可以自动类型转换或使用强制类型转换。支持连续赋值。</p>
</li>
<li>
<p>比较运算符（关系运算符）：<code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code>，<code>instanceof</code>（后续多态部分详解）。返回布尔值。</p>
<ul>
<li><code>==</code> 和 <code>!=</code> 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</li>
</ul>
</li>
<li>
<p>逻辑运算符：逻辑与 <code>&amp;</code>，短路与 <code>&amp;&amp;</code>、逻辑或 <code>|</code>, 短路或 <code>||</code>、逻辑非 <code>!</code>、逻辑异或 <code>^</code>。返回布尔值。</p>
</li>
<li>
<p>位运算符：<code>&amp;</code>，<code>|</code>，<code>^</code>，<code>~</code>，<code>&gt;&gt;</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;&gt;</code></p>
</li>
<li>
<p>条件运算符：<code>? :</code></p>
</li>
<li>
<p>复合赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>，不会改变变量本身的数据类型，即不会发生自动类型转换。</p>
<ul>
<li>示例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">i *= <span class="number">1.234</span>;</span><br><span class="line">System.out.println(i);<span class="comment">//编译通过，正常运行，输出12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字符串连接符：<code>+</code></p>
</li>
</ul>
<h2 id="81-自增-自减"><a class="markdownIt-Anchor" href="#81-自增-自减"></a> 8.1 自增、自减</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 自增（<code>++</code>）和自减（<code>--</code>）运算符是对变量在原始值的基础上进行加 <code>1</code> 或减 <code>1</code> 的操作，且 <strong>不会改变变量原有的数据类型</strong>。它们都有 <strong>前缀</strong> 和 <strong>后缀</strong> 两种形式。<strong>前缀形式</strong> 的运算规则可以概括为：“<strong>先自增（减）</strong>，<strong>后引用</strong>”；而 <strong>后缀形式</strong> 的运算规则可以概括为：“<strong>先引用</strong>，<strong>后自增（减）</strong>”。这里所说的 “引用”，指的是使用变量的值。另外，我们还要强调一个细节：无论是前缀形式还是后缀形式，<strong>自增自减运算符的优先级要高于赋值运算符</strong>。</p>
<h3 id="811-语句中仅有或-"><a class="markdownIt-Anchor" href="#811-语句中仅有或-"></a> 8.1.1 语句中仅有++或--</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 当一条语句中仅有 <code>++</code> 或 <code>--</code> 操作时，前缀形式与后缀形式的运算符没有任何区别。</p>
<h4 id="代码-1"><a class="markdownIt-Anchor" href="#代码-1"></a> 代码 1</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 输出结果是 <code>11</code>，其中第 <code>2</code> 条语句中仅有一个后缀形式 <code>++</code> 操作。</p>
<h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码 2</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">++a;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 输出结果同样是 <code>11</code>，与之前的那段代码基本一样，只是第 <code>2</code> 条语句中，后缀形式的 <code>++</code> 操作被换成了前缀形式。</p>
<h3 id="812-或-运算结果赋值给其他变量"><a class="markdownIt-Anchor" href="#812-或-运算结果赋值给其他变量"></a> 8.1.2 ++或--运算结果赋值给其他变量</h3>
<h4 id="1代码-1"><a class="markdownIt-Anchor" href="#1代码-1"></a> （1）代码 1</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 第 <code>2</code> 条语句对变量 <code>a</code> 进行了自增操作，并且把这个操作结果赋值给另一个变量 <code>b</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 语句中的变量 <code>b</code> 就是标题中所说的 “<strong>其他变量</strong>”，是指没有进行自增自减操作的其他变量。为什么要强调 “赋值给其他变量” 这个前提呢？就是因为如果把运算结果赋值给变量 <code>a</code> 自身，又会产生不同的效果，我们后面再去讲解赋值给自身的情况。现在先来分析程序，重点看第 <code>2</code> 条语句：变量 <code>a</code> 所进行的是前缀形式的自增操作，那么按照 “先自增，后引用” 的运算规则，<code>a</code> 的值首先变成 <code>3</code>，然后赋值 <code>b</code>。因此，给变量 <code>b</code> 赋值的是 <code>3</code>，那么输出结果就是 <code>3</code> 和 <code>3</code>。</p>
<h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2"></a> （2）代码 2</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 第 <code>2</code> 条语句发生了变化，变量 <code>a</code> 的自增操作变成了后缀形式。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 此时的程序输出结果是 <code>3</code> 和 <code>2</code>。为什么会是这样的运行结果呢？网上有很多资料对此的解释是：因为表达式中出现的是后缀形式的自增操作，因此，计算机会先使用 <code>a</code> 的值给 <code>b</code> 赋值，<code>a</code> 的值是 <code>2</code>，所以 <code>b</code> 被赋值为 <code>2</code>，<code>a</code> 在完成给 <code>b</code> 赋值的操作之后，才会完成自增变为 <code>3</code>，所以程序的输出结果为 <code>3</code> 和 <code>2</code>。<strong>这种解释看似非常合理</strong>，<strong>但其实是错误的</strong>！</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 按照这种解释，后缀形式的自增是在赋值之后才完成的，由此可以推出后缀形式的自增自减运算的优先级比赋值运算的优先级更低。而我们之前已经特意强调过：无论是前缀形式还是后缀形式，自增自减运算符的优先级都比赋值运算符要高。接下来问题来了：<strong>既然</strong> <code>++</code> <strong>和</strong> <code>--</code> <strong>的运算优先级高于赋值运算符</strong>，<strong>那么为什么赋值之前</strong> <code>a</code> <strong>的值没有自增为</strong> <code>3</code> <strong>呢</strong>？</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 其实这是个错觉！<code>a</code> <strong>在赋值给变量</strong> <code>b</code> <strong>之前</strong>，<strong>就已经完成了自增</strong>。为了讲解清楚真实情况，我们必须 <strong>科普</strong> 一个小常识，那就是：程序中如果用到某个变量的值，都会先把这个变量存入一个临时的空间，专业上把这个临时的空间称之为 “<strong>操作数栈</strong>”。我们之前所说的 “先引用，后自增” 中所说的这个 “<strong>引用</strong>” 操作，其实就是指 “<strong>把变量的值存入操作数栈</strong>” 这个动作。当程序中需要用到变量的值，计算机是从 “操作数栈” 中取出值进行运算，并不是我们想象的直接从变量所在的内存单元中取出数值。但是，如果语句中仅有 <code>++</code> 或 <code>--</code>，并不会把变量的值存入操作数栈，而是直接对变量进行自增或自减的操作，这也是为什么我们把语句中仅有 <code>++</code> 或 <code>--</code> 单独作为一种情况讲解的原因。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 科普完这个小常识之后，我们来解释刚才的代码为什么会输出 <code>3</code> 和 <code>2</code>。代码中出现用 <code>a</code> 的值给变量 <code>b</code> 赋值的语句，并且 <code>a</code> 的后面出现了 <code>++</code>，说明要对<code>a</code>进行 <strong>后缀形式的自增操作</strong>。按照我们刚才科普的小常识，<code>a</code> <strong>参与了赋值运算</strong>，那么就会把 <code>a</code> 的值存入操作数栈。因为 <code>a</code> 的自增是后缀形式的，所以要遵循 “先引用，后自增” 的运算规则，因此，<strong>计算机会首先取出</strong> <code>a</code> <strong>的值</strong> <code>2</code> <strong>存入操作数栈</strong>，<strong>然后再把</strong> <code>a</code> <strong>的值增加到</strong> <code>3</code>。做完自增操作之后，接下来会对变量 <code>b</code> 进行赋值操作。那么，是用哪个值给变量 <code>b</code> 赋值呢？就是 <strong>用刚才存到操作数栈中的那个</strong> <code>2</code> <strong>对变量</strong> <code>b</code> <strong>进行赋值</strong>，所以 <code>b</code> 最终得到的值是 <code>2</code>，因此输出结果是 <code>3</code> 和 <code>2</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 在这里，请大家注意一个细节，那就是：<strong>代码中的自增操作虽然是后缀形式的</strong>，<strong>但这个自增动作却是在赋值之前完成的</strong>，<strong>这也解释了后缀形式的自增运算优先级高于赋值运算</strong>，而网上很多资料中所说的 “先完成赋值，再去做自增操作” 是完全错误的。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <strong>代码</strong> <code>1</code> <strong>中第</strong> <code>2</code> <strong>条语句是</strong> “<code>int b = ++a;</code>”，<strong>会不会也把</strong> <code>a</code> <strong>的值存入操作数栈呢</strong>？答案是肯定的，只要是变量参与了 <strong>算术运算</strong>、<strong>赋值</strong>、<strong>被打印</strong> 这些操作，都会 <strong>取出变量的值存入操作数栈</strong>。因为语句中出现的是 <strong>前缀形式</strong> 的自增，所以 <strong>在值存入操作数栈之前就已经完成了自增操作</strong>。</p>
<h3 id="813-或-运算结果赋值给自身"><a class="markdownIt-Anchor" href="#813-或-运算结果赋值给自身"></a> 8.1.3 ++ 或 - - 运算结果赋值给自身</h3>
<h4 id="1代码-1-2"><a class="markdownIt-Anchor" href="#1代码-1-2"></a> （1）代码 1</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a = ++a;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 第 <code>2</code> 条语句，对 <code>a</code> 进行了前缀形式的自增，然后又赋值给 <code>a</code> 自身。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 因为 <code>a</code> 进行的是前缀形式的自增，所以运算规则是 “<strong>先自增</strong>，<strong>后引用</strong>”，自增之后 <code>a</code> 的值变成了 <code>3</code>，把 <code>3</code> 存入操作数栈，之后以 <code>3</code> 赋值给 <code>a</code>，所以 <code>a</code> 的值还是 <code>3</code>。</p>
<h4 id="2代码-2-2"><a class="markdownIt-Anchor" href="#2代码-2-2"></a> （2）代码 2</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a = a++;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 第 <code>2</code> 条语句将 <code>++a</code> 改成了 <code>a++</code>。这种情况下，程序输出 <code>a</code> 的值为 <code>2</code>，而不是 <code>3</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>a</code> 并没有按我们的想象实现自增，这是为什么呢？我们来分析一下整个运算的过程：计算机看到 “<code>=</code>” 右边是后缀形式的自增，因此以 “先引用，后自增” 的规则进行运算，先把 <code>a</code> 的值存入操作数栈，紧接着对 <code>a</code> 进行自增操作，<code>a</code> 的值变成了 <code>3</code>，最后又用操作数栈中的 <code>2</code> 对 <code>a</code> 进行赋值，<code>a</code> 的值又变成了 <code>2</code>。这样给我们造成了一种 <code>a</code> 没有进行自增的错觉。</p>
<h4 id="3代码-3"><a class="markdownIt-Anchor" href="#3代码-3"></a> （3）代码 3</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a = ++a + a++;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 第 <code>2</code> 条语句对 <code>a</code> 进行了两次自增操作，最终输出 <code>a</code> 的值是 <code>6</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <code>+</code> 加号 <strong>左边</strong> 运算规则是 “<strong>先自增</strong>，<strong>后引用</strong>”，自增之后 <code>a</code> 的值变成了 <code>3</code>，把 <code>3</code> 存入 <code>操作数栈1</code>；<code>+</code> 加号 <strong>右边</strong> 以 “<strong>先引用</strong>，<strong>后自增</strong>” 的规则进行运算，先把 <code>a</code> 的值存入 <code>操作数栈2</code>，这时放入 <code>操作数栈2</code> 的值是 <code>3</code>，紧接着对 <code>a</code> 进行自增操作，然后对 <code>操作数栈1</code> 和 <code>操作数栈2</code> 的数值进行加法运算，即 <code>3 + 3</code>，然后执行赋值运算，将 <code>6</code> 赋给 <code>a</code>。</p>
<h4 id="4代码-4"><a class="markdownIt-Anchor" href="#4代码-4"></a> （4）代码 4</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a += ++a + ++a;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 这一次，语句中出现了 <strong>复合赋值运算符</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 我们首先可以推导出 “<code>+=</code>” 右边的运算结果是 <code>7</code>。我们还知道，<strong>复合赋值运算符在完成运算的时候</strong>，<strong>要把右边当作整体</strong>。那么现在关键的问题就只剩一个了，那就是：“<code>+=</code>” 左边的 <code>a</code> 到底是多少？很多人认为 “<code>+=</code>” 左边 <code>a</code> 的值应该是 <code>4</code>，原因是 <code>++</code> 的运算优先级高于 <code>+=</code>，所以要先完成 <code>2</code> 次自增，完成了 <code>2</code> 次自增以后，<code>a</code> 的值已经变成了 <code>4</code>，由此推得 “<code>+=</code>” 左边 <code>a</code> 的值应该是 <code>4</code>，而最终的运算结果是 <code>11</code>（<code>4 + 7</code> 的和）。但实际运行程序的话，可以看到输出 <code>a</code> 的值为 <code>9</code> 而非 <code>11</code>。这是为什么呢？就是因为 <code>+=</code> 的优先级虽然低于 <code>++</code>，但是计算机在实际完成 <code>+=</code> 运算的时候会分为几个步骤进行。我们可以大致把 <code>+=</code> 运算分解为四大步骤：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> 1. 把 <code>+=</code> 左边的变量值存入 <code>操作数栈1</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> 2. 计算 <code>+=</code> 右边的表达式，并把计算结果存入 <code>操作数栈2</code>。<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> （此步骤其实是由多个具体步骤组成的）。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> 3. 把 <code>操作数栈1</code> 和 <code>操作数栈2</code> 中的数值相加得到运算结果。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> 4. 把运算结果存入变量 <code>a</code> 当中。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 现在最关键的问题是步骤 <code>1</code> 和 <code>2</code> 哪一个先被执行。如果 <strong>先执行步骤</strong> <code>1</code>，那么存入 <code>操作数栈1</code> 的是变量 <code>a</code> <strong>自增之前</strong> 的值，也就是 <code>2</code>；反之，如果 <strong>先执行步骤</strong> <code>2</code> ，那么存入 <code>操作数栈1</code> 的是变量 <code>a</code> <strong>自增之后</strong> 的值，也就是<code>4</code>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> <strong>真实的情况是先执行步骤</strong> <code>1</code>，也就是 <strong>把变量</strong> <code>a</code> <strong>自增之前的值存入</strong> <code>操作数栈1</code>。当语句中以复合赋值运算符给变量赋值的时候，计算机会先把复合赋值运算符左边变量的值存入操作数栈。因此，这段程序运行的结果是 <code>9</code>。</p>
<h4 id="5扩展"><a class="markdownIt-Anchor" href="#5扩展"></a> （5）扩展</h4>
<ul>
<li>
<p>开发中实现 <code>int</code> 类型变量 <code>+2</code> 的方式：</p>
<ul>
<li>
<p>方式<code>1</code>：<code>num</code> = <code>num</code> + <code>2</code>;</p>
</li>
<li>
<p>方式<code>2</code>：<code>num</code> += <code>2</code>;（<strong>推荐</strong>）</p>
</li>
</ul>
</li>
<li>
<p>开发中实现 <code>int</code> 类型变量 <code>+1</code> 的方式：</p>
<ul>
<li>
<p>方式<code>1</code>：<code>num = num + 1</code>;</p>
</li>
<li>
<p>方式<code>2</code>：<code>num += 1</code>;</p>
</li>
<li>
<p>方式<code>3</code>：<code>num++</code>;（<strong>推荐</strong>）</p>
</li>
</ul>
</li>
</ul>
<h2 id="82-逻辑运算符"><a class="markdownIt-Anchor" href="#82-逻辑运算符"></a> 8.2 逻辑运算符</h2>
<ul>
<li>
<p>逻辑运算符操作的都是 <code>boolean</code> 类型的变量，返回的结果也是 <code>boolean</code> 类型的值。</p>
</li>
<li>
<p>短路与 “<code>&amp;&amp;</code>” 的前后两个操作数必须都是 <code>true</code> 才返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li>
<p>短路或 “<code>||</code>” 只要两个操作数中有一个是 <code>true</code>，就返回<code>true</code>，否则返回<code>false</code>。</p>
</li>
<li>
<p>短路与 “<code>&amp;&amp;</code>” 和短路或 “<code>||</code>” 被称作 <strong>短路运算符</strong>。短路与（<code>&amp;&amp;</code>）和短路或（<code>||</code>）能够采用 <strong>最优化</strong> 的计算方式，从而提高效率。</p>
</li>
<li>
<p>短路与 “<code>&amp;&amp;</code>” 检查第一个表达式是否返回 “<code>false</code>”，如果是 “<code>false</code>” 则结果必为 “<code>false</code>”，不再检查其他内容。</p>
</li>
<li>
<p>短路或 “<code>||</code>” 检查第一个表达式是否返回 “<code>true</code>”，如果是 “<code>true</code>” 则结果必为 “<code>true</code>”，不再检查其他内容。</p>
</li>
<li>
<p>两种与（<code>&amp;&amp;</code> 和 <code>&amp;</code>）的运算规则基本相同，两种或（<code>||</code> 和 <code>|</code>）的运算规则也基本相同。其区别是：<code>&amp;</code> <strong>和</strong> <code>|</code> <strong>运算符是把逻辑表达式全部计算完</strong>，<strong>而</strong> <code>&amp;&amp;</code> <strong>和</strong> <code>||</code> <strong>运算符具有短路计算功能</strong>。<strong>开发中推荐使用</strong> <code>&amp;&amp;</code> <strong>和</strong> <code>||</code>。</p>
<ul>
<li>
<p><code>&amp;</code> 与 <code>&amp;&amp;</code> 的运算结果相同。当符号左边是 <code>true</code> 时，二者都会执行符号右边的运算；当符号左边是 <code>false</code> 时，<code>&amp;</code> 继续执行符号右边的运算，<code>&amp;&amp;</code> 不再执行符号右边的运算。</p>
</li>
<li>
<p><code>|</code> 与 <code>||</code> 的运算结果相同。当符号左边是 <code>false</code> 时，二者都会执行符号右边的运算；当符号左边是 <code>true</code> 时，<code>|</code> 继续执行符号右边的运算，<code>||</code> 不再执行符号右边的运算。</p>
</li>
<li>
<p>例：程序输出结果</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">if</span> ((z++ == <span class="number">40</span>) &amp;&amp; (y = <span class="literal">true</span>))&#123;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((x = <span class="literal">false</span>) || (++z == <span class="number">43</span>))&#123;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;z = &quot;</span> + z); <span class="comment">// z = 44</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>逻辑非 “<code>!</code>” 就是指原值的相反值。</p>
</li>
<li>
<p>逻辑异或 “<code>^</code>” 的前后两个操作数的值不相同，则异或结果为 <code>true</code>，反之异或结果为 <code>false</code>。</p>
</li>
</ul>
<div align=center>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a &amp; b</th>
<th style="text-align:center">a &amp;&amp; b</th>
<th style="text-align:center">a | b</th>
<th style="text-align:center">a || b</th>
<th style="text-align:center">!a</th>
<th style="text-align:center">a ^ b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><b>true</b></td>
<td style="text-align:center"><b>true</b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
</tr>
<tr>
<td style="text-align:center"><b>true</b></td>
<td style="text-align:center"><b>false</b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
</tr>
<tr>
<td style="text-align:center"><b>false</b></td>
<td style="text-align:center"><b>true</b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
</tr>
<tr>
<td style="text-align:center"><b>false</b></td>
<td style="text-align:center"><b>false</b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
<td style="text-align:center"><b><font color="red">true</font></b></td>
<td style="text-align:center"><b><font color="red">false</font></b></td>
</tr>
</tbody>
</table>
</div>
<h2 id="83-位运算符"><a class="markdownIt-Anchor" href="#83-位运算符"></a> 8.3 位运算符</h2>
<ul>
<li>
<p>位运算是直接对整数的<strong>二进制</strong>进行的运算，即位运算符操作的都是整型的数据。</p>
</li>
<li>
<p><strong>按位与</strong><code>＆</code>：如果相对应二进制位都是 <code>1</code>，则结果为 <code>1</code>，否则为 <code>0</code>。</p>
</li>
<li>
<p><strong>按位或</strong><code>|</code>：如果相对应二进制位都是 <code>0</code>，则结果为 <code>0</code>，否则为 <code>1</code>。</p>
</li>
<li>
<p><strong>按位异或</strong><code>^</code>：如果相对应二进制位值相同，则结果为 <code>0</code>，否则为 <code>1</code>。</p>
<ul>
<li>
<p>按位异或可用于不借助第三个变量实现两个数的交换，示例如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1;</span><br><span class="line"><span class="type">int</span> num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;<span class="comment">// (num1 ^ num2) ^ num2 得到 num1 的值，然后赋给num2</span></span><br><span class="line">num1 = num1 ^ num2;<span class="comment">// (num1 ^ num2) ^ num2，这里的 num2 已经替换为 num1，所以左式得到原有 num2 的值，然后赋给 num1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>按位取反</strong> <code>~</code>：按位取反运算符翻转二进制操作数的每一位（包含符号位），即 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。<strong>负数操作的是补码</strong>。</p>
</li>
<li>
<p><strong>按位左移</strong> <code>&lt;&lt;</code>：按位左移运算符。左操作数按位左移右操作数指定的位数，即丢弃左边指定位数，右边补 <code>0</code>。<strong>在一定范围内</strong>（按位左移不影响数字原二进制位），<strong>左操作数左移</strong> <code>n</code> <strong>位相当于乘</strong> <code>2</code> <strong>的</strong> <code>n</code> <strong>次幂</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>）。</p>
<ul>
<li>
<p>当 <code>int</code> 类型进行左移操作时，左移位数大于等于 <code>32</code> 位操作时，会先对 <code>32</code> 取模（<code>%</code>）后再进行左移操作。也就是说左移<code>32</code>位相当于不进行移位操作，左移<code>40</code>位相当于左移<code>8</code>位（<code>40 % 32 = 8</code>）。当 <code>long</code> 类型进行左移操作时，<code>long</code> 类型在二进制中的体现是 <code>64</code> 位的，因此取模操作的基数也变成了 <code>64</code>，也就是说左移 <code>64</code> 位相当于没有移位，左移 <code>72</code> 位相当于左移 <code>8</code> 位（<code>72 % 64 = 8</code>）。</p>
</li>
<li>
<p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</p>
</li>
<li>
<p>其它几种整型 <code>byte</code>，<code>short</code> 移位前会先转换为 <code>int</code> 类型（<code>32</code> 位）再进行移位。</p>
</li>
</ul>
</li>
<li>
<p><strong>按位右移</strong> <code>&gt;&gt;</code>：按位右移运算符。左操作数按位右移右操作数指定的位数，即丢弃右边指定位数，左边补上 <strong>符号位</strong>（<strong>正数符号位</strong> <code>0</code>，<strong>负数符号位</strong> <code>1</code>）。<strong>正数左操作数右移</strong> <code>n</code> <strong>位相当于除</strong> <code>2</code> <strong>的</strong> <code>n</code> <strong>次幂</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>），<strong>然后取整</strong>。<strong>负数操作的是补码</strong>。</p>
<ul>
<li>和左移一样，<code>int</code> 类型移位大于等于 <code>32</code> 位时，<code>long</code> 类型大于等于 <code>64</code> 位时，会先做求余处理再位移处理，<code>byte</code>，<code>short</code> 移位前会先转换为 <code>int</code> 类型（<code>32</code>位）再进行移位。</li>
</ul>
</li>
<li>
<p><strong>无符号右移</strong> <code>&gt;&gt;&gt;</code>：无符号右移即按位右移 <strong>补零操作符</strong>。左操作数的值按右操作数指定的位数右移，移动得到的左边空位 <strong>以零填充</strong>。</p>
</li>
</ul>
<h2 id="84-条件运算符"><a class="markdownIt-Anchor" href="#84-条件运算符"></a> 8.4 条件运算符</h2>
<ul>
<li>
<p><code>Java</code> 提供了一个特别的 <strong>三元运算符</strong>（也叫三目运算符）经常用于取代某个类型的 <code>if-then-else</code> 语句。</p>
</li>
<li>
<p><strong>条件运算符是</strong> <code>Java</code> <strong>唯一的三目运算符</strong>，表示为 “<code>? :</code>”，使用该运算符时需要有 <strong>三个操作数</strong>，因此称其为三目运算符。使用条件运算符的一般语法结构为：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = &lt;expression&gt; ? &lt;statement1&gt; : &lt;statement2&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，<code>expression</code> 是一个布尔表达式。当 <code>expression</code> 为真时，执行 <code>statement1</code>， 否则就执行 <code>statement2</code>。<code>statement1</code> 和 <code>statement2</code> 返回的值的 <strong>数据类型要能够统一</strong>，可以被 <code>result</code> 接收。</li>
</ul>
</li>
<li>
<p>三元运算符可以进行嵌套，结构为：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = &lt;expression1&gt; ? &lt;statement1&gt; : &lt;expression1&gt; ? &lt;statement2&gt; : &lt;statement3&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>凡是可以使用三元运算符的地方，都可以改写为 <code>if-else</code>，反之不成立。</p>
</li>
<li>
<p>如果程序既可以使用三元运算符，又可以使用 <code>if-else</code> 结构，那么 <strong>优先选择三元运算符</strong>。原因：简单、执行效率高。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xindong2020.love">Mr.DONG</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xindong2020.love/paper/e2453482.html">https://xindong2020.love/paper/e2453482.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xindong2020.love" target="_blank">Mr.DONG の 自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://s6.jpg.cm/2022/09/07/PXRPf5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/paper/671cc460.html"><img class="prev-cover" src="https://s6.jpg.cm/2022/09/07/PXPj1L.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 基础语法（下）</div></div></a></div><div class="next-post pull-right"><a href="/paper/518e9178.html"><img class="next-cover" src="https://s6.jpg.cm/2022/09/07/PXPOYk.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 基础语法（上）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/paper/e6fa4949.html" title="Java 入门"><img class="cover" src="https://s6.jpg.cm/2022/09/07/PXRPf5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-28</div><div class="title">Java 入门</div></div></a></div><div><a href="/paper/671cc460.html" title="Java 基础语法（下）"><img class="cover" src="https://s6.jpg.cm/2022/09/07/PXPj1L.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">Java 基础语法（下）</div></div></a></div><div><a href="/paper/518e9178.html" title="Java 基础语法（上）"><img class="cover" src="https://s6.jpg.cm/2022/09/07/PXPOYk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-29</div><div class="title">Java 基础语法（上）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s6.jpg.cm/2022/09/07/PXPXyi.th.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mr.DONG</div><div class="author-info__description">Mr.DONG学习记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fandong93"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fandong93" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dongf19931107@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到 Mr.DONG の 自习室</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3. 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3.1 隐式转换（自动类型转换）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3.2 显式转换（强制类型转换）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-string"><span class="toc-text"> 4. String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-java-%E5%8F%98%E9%87%8F"><span class="toc-text"> 5. Java 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text"> 5.1 全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text"> 5.1.1 成员变量（实例变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text"> 5.1.2 静态变量（类变量）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text"> 5.2 局部变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-java-%E5%B8%B8%E9%87%8F"><span class="toc-text"> 6. Java 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-interface-%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-text"> 6.1 interface 中定义常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-class-%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-text"> 6.2 Class 中定义常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-enum-%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-text"> 6.3 enum 定义常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9D%A5%E9%85%8D%E7%BD%AE%E5%B8%B8%E9%87%8F"><span class="toc-text"> 6.4 通过配置文件来配置常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text"> 7. 命名规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 8. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F"><span class="toc-text"> 8.1 自增、自减</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BB%85%E6%9C%89%E6%88%96-"><span class="toc-text"> 8.1.1 语句中仅有++或--</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text"> 代码 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text"> 代码 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#812-%E6%88%96-%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F"><span class="toc-text"> 8.1.2 ++或--运算结果赋值给其他变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BB%A3%E7%A0%81-1"><span class="toc-text"> （1）代码 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%BB%A3%E7%A0%81-2"><span class="toc-text"> （2）代码 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#813-%E6%88%96-%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E8%87%AA%E8%BA%AB"><span class="toc-text"> 8.1.3 ++ 或 - - 运算结果赋值给自身</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BB%A3%E7%A0%81-1-2"><span class="toc-text"> （1）代码 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%BB%A3%E7%A0%81-2-2"><span class="toc-text"> （2）代码 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BB%A3%E7%A0%81-3"><span class="toc-text"> （3）代码 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81-4"><span class="toc-text"> （4）代码 4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%89%A9%E5%B1%95"><span class="toc-text"> （5）扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 8.2 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 8.3 位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 8.4 条件运算符</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/paper/671cc460.html" title="Java 基础语法（下）"><img src="https://s6.jpg.cm/2022/09/07/PXPj1L.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 基础语法（下）"/></a><div class="content"><a class="title" href="/paper/671cc460.html" title="Java 基础语法（下）">Java 基础语法（下）</a><time datetime="2022-08-31T16:00:00.000Z" title="发表于 2022-09-01 00:00:00">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/paper/e2453482.html" title="Java 基础语法（中）"><img src="https://s6.jpg.cm/2022/09/07/PXRPf5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 基础语法（中）"/></a><div class="content"><a class="title" href="/paper/e2453482.html" title="Java 基础语法（中）">Java 基础语法（中）</a><time datetime="2022-08-29T16:00:00.000Z" title="发表于 2022-08-30 00:00:00">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/paper/518e9178.html" title="Java 基础语法（上）"><img src="https://s6.jpg.cm/2022/09/07/PXPOYk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 基础语法（上）"/></a><div class="content"><a class="title" href="/paper/518e9178.html" title="Java 基础语法（上）">Java 基础语法（上）</a><time datetime="2022-08-28T16:00:00.000Z" title="发表于 2022-08-29 00:00:00">2022-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Mr.DONG</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>